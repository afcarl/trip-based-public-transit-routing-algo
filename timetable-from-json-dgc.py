#!/usr/bin/env python3

import itertools as it, operator as op, functools as ft
import os, sys, pathlib, random, re, pickle

import tb_routing as tb, test._common as c


def flat_dt(stop_a, stop_b, speed_kmh, dt_base=0):
	km = (abs(stop_a.lon - stop_b.lon)**2 + abs(stop_a.lat - stop_b.lat)**2)**0.5
	return dt_base + km / speed_kmh

def main(args=None):
	import argparse
	parser = argparse.ArgumentParser(
		description='Generate mock transport network timetable'
				' from a json-dgc (https://github.com/eimink/json-dgc/) graph.'
			' Graph node name format must be: "L" x1 "-" y1 ["/L" x2 "-" y2] ...,'
				' where x values are line-ids and y values are sortable to connect stops of same line.'
			' Examples: L4-b, L1-a/L3-j.'
			' Edge arrows do not matter at all, only node names/positions do.')
	parser.add_argument('dag_json', help='DAG JSON/YAML file saved from json-dgc app.')
	parser.add_argument('tt_pickle', help='Path to store pickled Timetable object to.')
	parser.add_argument('-s', '--seed',
		help='Randomness seed (any string) for generated stuff.'
			' Generated by ordered nodes/edges concatenation by default.')
	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	with pathlib.Path(opts.dag_json).open() as src: dag = c.yaml_load(src)
	dag = c.dmap(dag)
	dag.edges = list(c.dmap(e) for e in dag.edges)
	dag.nodes = list(c.dmap(n) for n in dag.nodes)

	seed = opts.seed
	if not seed:
		seed = list()
		for n in sorted(dag.nodes, key=op.itemgetter('id')):
			seed.extend([n.id, n.title])
		for e in sorted(dag.edges, key=op.itemgetter('source', 'target')):
			seed.extend([e.source, e.target])
		seed = '\0'.join(map(str, seed))
	random.seed(seed)

	types = tb.t.public
	trips, stops, footpaths = types.Trips(), types.Stops(), types.Footpaths()

	lines = dict()
	for node in dag.nodes:
		node_lines = node.title.split('/')
		m = re.search('^L([^-]+)-(.*)$', node.title)
		if not m: raise ValueError(node)
		line_id, line_seq = m.groups()
		stop = stops.add(types.Stop('s{:02d}'.format(node.id), node.title, node.x, node.y))
		lines.setdefault(line_id, list()).append((line_seq, stop))

	for line_id, line in sorted(lines.items()):
		if random.random() < 0.7:
			line_dts_start, line_dts_end = random.randint(0, 10), random.randint(18, 24)
		elif random.random() < 0.5:
			line_dts_start = random.randint(5, 17)
			line_dts_end = random.randint(line_dts_start, 23)
			while line_dts_end - line_dts_start < 2:
				line_dts_start = random.randint(5, line_dts_end)
		else:
			line_dts_start, line_dts_end = random.randint(12, 18), random.randint(20, 24)
		line_dts_start = 3600 * line_dts_start + 60 * random.randint(0, 60//5-1) * 5
		line_dts_end = 3600 * line_dts_end
		line_dts_interval = random.randint(1, 5)*30*60
		line_kmh = random.randint(5,10) * 10
		line_stops = list(map(op.itemgetter(1), sorted(line)))

		for trip_seq in range(50):
			trip_dts_start = line_dts_start + line_dts_interval * trip_seq
			if trip_dts_start > line_dts_end: break
			trip = types.Trip()
			for stopidx, stop in enumerate(line_stops):
				if not trip.stops: dts_arr = trip_dts_start
				else:
					ts = trip.stops[-1]
					dts_arr = ts.dts_dep + divmod(flat_dt(ts.stop, stop, line_kmh), 60)[0] * 60
				dts_dep = dts_arr + random.randint(1,6) * 5
				trip.add(types.TripStop(trip, stopidx, stop, dts_arr, dts_dep))

	for stop in stops: footpaths.add(stop, stop, 2*60)
	for stop_a, stop_b in it.permutations(stops, 2):
		footpaths.add(stop_a, stop_b, int(flat_dt(stop_a, stop_b, 5, 2*60)))

	timetable = types.Timetable(stops, footpaths, trips)
	with pathlib.Path(opts.tt_pickle).open('wb') as dst: pickle.dump(timetable, dst)

if __name__ == '__main__': sys.exit(main())
